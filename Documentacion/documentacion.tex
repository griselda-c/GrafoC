\documentclass[a4paper,12pt]{article}

\usepackage[T1]{fontenc}%encoding de los fonts del pdf (para copiar y pegar)
\usepackage[spanish]{babel} %idioma español para los cortes de linea
\usepackage[utf8]{inputenc} %encoding del .tex
\usepackage{amsmath} %paquete de matematica
\usepackage[margin=1.5cm]{geometry} %margenes
\usepackage{enumerate} %mejor enumerate
\usepackage{xspace} %espacios despues de un comando
\usepackage[pdftitle={},pdfauthor={},pdfcreator={},pdfsubject={},pdfkeywords={},colorlinks=true,linkcolor=blue,citecolor=blue]{hyperref} %hiperlinks
\usepackage{listings} %para escribir codigo C++

\newcommand{\Grafo}{\textsc{Grafo}\xspace}
\newcommand{\Code}[1]{\lstinline[basicstyle={\tt}]@#1@}
\newcommand{\N}{\mathcal{N}}

\lstset{
  numbers=left,
  numberstyle=\small,
  tabsize=2,
  frame=BRtl,
  basicstyle={\small\tt},
  aboveskip={12pt},
  belowskip={12pt},
  captionpos=b,
  framerule=1.5pt,
  %linewidth=.9\linewidth
  xleftmargin=3em,
  xrightmargin=3em,
  emphstyle={\color{red}}
}


\begin{document}

% Title of paper
\title{TIP:  Implementación de algoritmos y estructuras de datos eficientes para grafos}

% List of authors, with corresponding author marked by asterisk
\author{Alejandro Merlo \and Griselda Cardozo}
\date{(draft \today)} % Sin fecha.

\maketitle

\tableofcontents

\section{Resumen}
\label{sec:resumen}


\section{Introducción}
\label{sec:introduccion}

Un grafo es un par $G = (V, E)$ donde $V$ son vértices y $E$ son aristas que reflejan la conexión entre un par de vértices.  Los grafos se usan para modelar objetos de aplicaciones reales en forma abstracta.  Por ejemplo, en una red social las personas son representadas por los vértices y las aristas representan las relaciones entre ellas.  La ventaja de los grafos es que proveen una terminología común, blah.  La teoría de grafos se encarga del estudio de grafos y, en particular, la teoría algoritmica de grafos se encarga de los problemas computacionales asociados.


Este trabajo surge de la necesidad de verificar la viabilidad y dificultad de implementar la estructura $h$-grafo descripta por Lin et al. en~\cite{}``Arboricity, $h$-index, and dynamic algorithms''.   Esta estructura implementa el \emph{tipo abstracto de datos} (TAD) \Grafo.  Esta estructura esta pensada para aplicaciones que utilizan grafos dinámicos.  Por \emph{dinámico} nos referimos a que permite la inserción y borrado de vértices y aristas, a la vez que provee funciones de consulta.  La ventaja de esta estructura es que es muy eficiente en grafos ralos, i.e., grafos que tienen una baja \emph{arboricidad}.  

La estructura $h$-grafo es conceptualmente simple.  La misma consiste de tres campos $(d(v), L(v), H(v))$ por cada vértice $v$ de un grafo $G$, donde $d(v)$ es el grado de $v$, $L(v)$ son los vecinos de $v$ con grado menor a $d(v)$ y $H(v)$ son los vecinos de $v$ con grado al menos $d(v)$.  Asimismo, la estructura mantiene una serie de punteros a fin de que las operaciones puedan resolverse eficientemente.  

Los objetivos principales de este trabajo son:
\begin{itemize}
  \item desarrollar el TAD grafo implementado con la estructura $h$-grafo,
  \item verificar que la eficiencia teórica coincide con la de nuestra implementación, y
  \item testear la eficiencia de la estructura en grafos ralos grandes.
\end{itemize}

El presente documento esta organizado de la siguiente forma.  En la Sección \ref{sec:tad grafo} hablaremos sobre el Tipo Grafo donde haremos un repaso de la interfaz que tiene en general todos los grafos.  En la Sección \ref{sec:h-grafo} explicaremos la estructura del $h$-graph y describiremos los diferentes algoritmos para implementar la interfaz del grafo. La Sección \ref{sec:c++} hablaremos sobre la implementación en c++. Esta sección esta dividia en dos subsecciones. En la subsección \ref{sec:c++:interfaz} describiremos la interfaz del $h$-graph en c++. En la subsección \ref{sec:c++:estructura} explicaremos la estructura en $c++$ para implementar el $h$-graph. Por último en la sección \ref{sec:experimentación} expondremos los resultados de la experimentación de medir la eficiencia de la estructura $h$-graph.

\section{Preliminares}
\label{sec:definiciones}

Recordemos que uno de los objetivos de este trabajo es implementar un TAD grafo.  El TAD grafo representa el objeto \emph{grafo} que se estudia en matemática.  En esta sección presentamos las definiciones centrales de un grafo que impactan en el desarrollo de nuestro TAD.

%Definiciones matematicas
Un \emph{grafo} es un par $(V, E)$ donde $V$ \ldots (ver Figura~\ref{fig:definiciones} en donde se ejemplifican muchas de las definiciones).  Para cada $vw \in E$, decimos que $v$ y $w$ son \emph{vecinos} o \emph{adjacentes}.  El grado de $v$ es la cantidad de vecinos que tiene.  El $k$-vecindario de $v$ es el conjunto de todos los vecinos de $v$ que tienen grado $k$, para algun $k$ dado.  Al conjunto de todos los vecinos de $v$ lo llamamos, simplemente, su \emph{vecindario}.

\begin{figure}
  \centering
  \fbox{Figura de un grafo en el que mostramos las definciones}

  \caption{Grafo cuyo conjunto de vértices es $V = $ y cuyo conjunto de aristas es $E =$.  En este grafo.}\label{fig:definiciones}
\end{figure}


Camino: es cualquier subconjunto de aristas contiguas, es decir, donde se cumpla que para cada par de aristas, el último vértice de la primer arista es el mismo que el primer vértice de la segunda arista; salvando el caso de la primera y de la última arista que pueden cumplir o no este requisito.  Circuito: es un subconjunto de las aristas del grafo que forman un camino donde el primer vertice es el último en ser accedido.  Bosque: es aquel grafo que no tiene circuitos.  Arboricidad: es la mínima cantidad de bosques con aristas disjuntas que se pueden formar dentro del grafo.

\section{El Tipo Grafo}
\label{sec:tad grafo}

\def\lstlistingname{Pseudocódigo}
 
El propósito de esta sección es presentar la interfaz abstracta del objeto grafo que implementaremos.  Este objeto es dinámico en el sentido que va cambiando debido a que permite agregar y borrar vértices y aristas.  Asimismo, ofrece distintas operaciones de consulta, que estan pensadas para poder recorrer eficientemente el vecindario de las distintas aristas del grafo.  Estas operaciones son muy útiles, por ejemplo, cuando uno quiere analizar la estructura local del grafo.  Es decir, cómo se conectan los vecinos de un vertice $v$ dado.  

Para describir la interfaz del TAD grafo, vamos a detallar cada una de las operaciones junto con sus propósitos y sus requerimientos.  Esta descripción será de alto nivel tal y como se desarrolla en~\cite{}.  La idea de esta descripcion es fijar los conceptos necesarios para la posterior descripción de su implementación en el lenguaje C++.  Asimismo, mostraremos un ejemplo de su uso potencial y describiremos la complejidad temporal esperada.  Obviamente, esta complejidad está en función de la implementación que describimos en la Seccion~\ref{sec:h-grafo}.  

l tipo grafo es paramétrico, es decir, que almacena objetos de un tipo \texttt{elem}

\subsection{\texttt{create\_graph()}}
\label{sec:tad grafo:create-graph}

Crea un objeto \Code{G} que representa un grafo $G$ de elementos \Code{elem}. Retorna un puntero \Code{G} al nuevo grafo creado. Este objeto guarda cierta información correspondiente a los vertices y sus vecinos. El \lstlistingname~\ref{lst:pseudo:create_graph} muestra cómo crear un grafo $G$ vacío.


\begin{description}
  \item [Propósito:] crea un \Code{G} sin vertices ni aristas.
  \item [Retorna:] un puntero \Code{G} al grafo $G$.
  \item [Complejidad temporal:]
\end{description}


\begin{lstlisting}[caption={Ejemplo de uso de create\_graph},gobble=2,float=ht,label={lst:pseudo:create_graph},emph={create_graph}]
  G := create_graph()
\end{lstlisting}

\subsection{\texttt{insert\_vertex(G, info)}}
\label{sec:tad grafo:insert-vertex}

Modifica un objeto \Code{G} que representa un grafo $G$, a fin de representar el grafo $H$ que se obtiene de insertar un nuevo vértice $v$ en $G$.  Retorna un puntero \Code{v} al nuevo vértice $v$ agregado.  Este puntero \Code{v} debe usarse para interactuar con $G$ a fin de modificar sus propiedades.  Notar que el vértice $v$ es un objeto conocido sólo por $G$ y no es compartido con otros grafos.  A este vertice se le puede asociar cierta información que es la reflejada por el parametro \Code{info}.  Blah.

El \lstlistingname~\ref{lst:pseudo:insert_vertex} muestra cómo usar \texttt{insert\_vertex}.
  
\begin{description}
  \item [Parámetros:] \Code{G} representa un grafo $G$ e \Code{info} es cualquier objeto.
  \item [Propósito:] modifica \Code{G} para representar un grafo $G + v$.
  \item [Retorna:] un puntero \Code{v} al vértice $v$.
  \item [Complejidad temporal:]
\end{description}


\begin{lstlisting}[caption={Ejemplo de uso de insert\_vertex.  Crea un grafo $G$ con dos vértices, ambos con la letra ``a'' como información.  Luego, el ciclo imprime ``aa''. Ver Sección~\ref{sec:tad grafo:vertex-iterator} para más información de \texttt{vertex\_iterator}.},gobble=2,float=ht,label={lst:pseudo:insert_vertex},emph={insert_vertex}]
  G := create_graph()
  v := insert_vertex(G, 'a')
  w := insert_vertex(G, 'a')
      for v in vertex_iterator(G):
          print get_info(v)
\end{lstlisting}


\subsection{\texttt{remove\_vertex(G, v)}}
\label{sec:tad grafo:remove-vertex}

Modifica un objeto \Code{G} que representa un grafo $G$, a fin de representar el grafo $H$ que se obtiene de remover el vértice existente \Code{v} que representa al vertice $v$ en $G$.
  
\begin{description}
  \item [Parámetros:] \Code{G} representa un grafo $G$ y \Code{v} representa un vertice existente $v$ de $G$.
  \item [Propósito:] modifica \Code{G} para representar un grafo $G - v$.
  \item [Complejidad temporal:]
\end{description}


\begin{lstlisting}[caption={Ejemplo de uso de remove\_vertex. El código crea un grafo $G$ con dos vértices, el primero \texttt{v} representa al vértice $v$ con la letra 'a' y el segundo \texttt{w} representa al vértice $w$ con la letra 'b' como infomación. Luego, remueve \texttt{v} del grafo y el ciclo imprime ``b'' como resultado. Ver Sección~\ref{sec:tad grafo:vertex-iterator} para más información de \texttt{vertex\_iterator}.},gobble=2,float=ht,label={lst:pseudo:remove_vertex},emph={remove_vertex}]
  G := create_graph()
  v := insert_vertex(G, 'a')
  w := insert_vertex(G, 'b')
  remove_vertex(G, v)
      for vt in vertex_iterator(G):
          print get_info(vt)
\end{lstlisting}


\subsection{\texttt{add\_edge(G, v, w)}}
\label{sec:tad grafo:add-edge}

Modifica un objeto \Code{G} que representa un grafo $G$, a fin de representar el grafo $H$ que se obtiene de agregar la arista $vw$ conformada por \Code{v} y \Code{w} que representan los vertices $v$ y $w$ en $G$.

\begin{description}
  \item [Parámetros:] \Code{G} representa un grafo $G$, \Code{v} y \Code{w} representan los vertices existentes $v$ y $w$ de $G$.
  \item [Propósito:] modifica \Code{G} para representar un grafo $G + vw$.
  \item [Complejidad temporal:]
\end{description}


\begin{lstlisting}[caption={Ejemplo de uso de add\_edge. El código crea un grafo $G$ con dos vértices, el primero \texttt{v} representa al vértice $v$ con el número 1 y el segundo \texttt{w} representa al vértice $w$ con el número 2 como infomación. Luego, crea la arista $vw$ entre estos dos vertices dentro del grafo $G$. El ciclo imprime cada uno de los valores de los vecinos de $v$, en este caso como $w$ es su único vecino imprime ``2''. Ver Sección~\ref{sec:tad grafo:neighbor-iterator} para más información de \texttt{neghbor\_iterator}.},gobble=2,float=ht,label={lst:pseudo:add_edge},emph={add_edge}]
  G := create_graph()
  v := insert_vertex(G, 1)
  w := insert_vertex(G, 2)
  add_edge(G, v, w)
      for n in neighbor_iterator(v):
          print get_info(n)
\end{lstlisting}


\subsection{\texttt{remove\_edge(G, v, w)}}
\label{sec:tad grafo:remove-edge}

Modifica un objeto \Code{G} que representa un grafo $G$, a fin de representar el grafo $H$ que se obtiene de remover la arista $vw$ conformada por \Code{v} y \Code{w} que representan los vértices $v$ y $w$ en $G$.

\begin{description}
  \item [Parámetros:] \Code{G} representa un grafo $G$, \Code{v} y \Code{w} representan vertices adyacentes $v$ y $w$ de $G$, respectivamente.
  \item [Propósito:] modifica \Code{G} para representar un grafo $G - \{vw\}$.
  \item [Complejidad temporal:]
\end{description}


\begin{lstlisting}[caption={Ejemplo de uso de \Code{remove_edge}.  En el código se crea un grafo $G$ con vértices $v$, $w$ y $x$, siendo $v$ adyacente tanto a $w$ como a $x$.  Luego se utiliza \Code{remove_edge} para eliminar la arista $vw$, con lo cual $v$ queda adyacente únicamente a $x$.  El ciclo final, pues, imprime el valor $3$ asociado a $x$.  Ver Sección~\ref{sec:tad grafo:neighbor-iterator} para más información de \Code{neghbor_iterator}.},gobble=2,float=ht,label={lst:pseudo:remove_edge},emph={remove_edge}]
  G := create_graph()
  v := insert_vertex(G, 1)
  w := insert_vertex(G, 2)
  x := insert_vertex(G, 3)
  add_edge(G, v, w)
  add_edge(G, v, x)
  remove_edge(G, v, w)
      for n in neighbor_iterator(v):
          print get_info(n)
\end{lstlisting}


\subsection{\texttt{add\_vertex(G, info, N)}}
\label{sec:tad grafo:add-vertex}

Modifica un objeto \Code{G} que representa un grafo $G$, a fin de representar el grafo $H$ que se obtiene de agregar un nuevo vertice $v$ cuya información está reflejada en el parámetro \Code{info} y una lista de punteros \Code{N} que representa al vecindario $N$ que será asociado a $v$

\begin{description}
  \item [Parámetros:] \Code{G} representa un grafo $G$, \Code{info} es cualquier objeto y \Code{N} representa el vecindario $N$.
  \item [Propósito:] modifica \Code{G} para representar un grafo $G + vn$ donde $n$ es cada elemento de $N$.
  \item [Retorna:] un puntero \Code{v} al vértice $v$.
  \item [Complejidad temporal:]
\end{description}


\begin{lstlisting}[caption={Ejemplo de uso de add\_vertex. El código crea un grafo $G$ con tres vertices, teniendo el tercer vertice, llamado $v$, a los otros dos como vecinos. Luego, el ciclo imprime ``12''.},gobble=2,float=ht,label={lst:pseudo:add_vertex},emph={add_vertex}]
  G := create_graph()
  x := insertVertex(G, 1);
  y := insertVertex(G, 2);
  v := add_vertex(G, 3, {x, y})
      for w in neighbor_iterator(v):
          print get_info(w)
\end{lstlisting}


\subsection{\Code{vertex_iterator(G)}}%iterador
\label{sec:tad grafo:vertex-iterator}

Provee de un puntero que permite desplazarse a través de los distintos vertices del objeto \texttt{G} que representa un grafo $G$ y acceder a ellos, a fin de poder manipularlos de una forma rápida y simple.

\begin{description}
  \item [Parámetros:] \Code{G} representa un grafo $G$.
  \item [Propósito:] Proveer al usuario de un mecanismo para iterar los vertices de $G$.
  \item [Retorna:] un iterador \Code{i} a los vértices de $G$.
  \item [Complejidad temporal:]
\end{description}


\begin{lstlisting}[caption={Ejemplo de uso de vertex\_iterator. El código crea un grafo $G$ con el vertice 1 y el vertice 2. Luego, mediante el iterador de $G$ se recorre sus vertices y el ciclo imprime ``12''.},gobble=2,float=ht,label={lst:pseudo:vertex_iterator},emph={vertex_iterator}]
  G := create_graph()
  x := insertVertex(G, 1);
  y := insertVertex(G, 2);
      for v in vertex_iterator(G):
          print get_info(v)
\end{lstlisting}


\subsection{\Code{neighbor_iterator(v)}}%iterador
\label{sec:tad grafo:neighbor-iterator}

Provee de un puntero que permite desplazarse a través de los distintos vecinos de menor grado al del objeto \texttt{v} que representa un vértice $v$ y acceder a ellos, a fin de poder manipularlos de una forma rápida y simple.

\begin{description}
  \item [Parámetros:] \Code{v} representa un vertice $v$.
  \item [Propósito:] Proveer al usuario de un mecanismo para iterar los vecinos de menor grado de $v$.
  \item [Retorna:] un iterador \Code{i} a los vecinos de menor grado de $v$.
  \item [Complejidad temporal:]
\end{description}


\begin{lstlisting}[caption={Ejemplo de uso de neighbor\_iterator. El código crea un grafo $G$ con el vertice 1, el vertice 2 y el vertice 3. Luego, mediante el iterador de $v$ se recorre sus vecinos de menor grado y el ciclo imprime ``12''.},gobble=2,float=ht,label={lst:pseudo:neighbor_iterator},emph={neighbor_iterator}]
  G := create_graph()
  x := insertVertex(G, 1);
  y := insertVertex(G, 2);
  v := add_vertex(G, 3, {x, y})
      for w in neighbor_iterator(v):
          print get_info(w)
\end{lstlisting}


\subsection{\Code{H_neighbors(v)}}%iterador
\label{sec:tad grafo:H-neighbors}

Provee de un puntero que permite desplazarse a través de los distintos vecinos de grado mayor o igual al del objeto \texttt{v} que representa un vértice $v$ y acceder a ellos, a fin de poder manipularlos de una forma rápida y simple.

\begin{description}
  \item [Parámetros:] \Code{v} representa un vertice $v$.
  \item [Propósito:] Proveer al usuario de un mecanismo para iterar los vecinos de grado mayor o igual al de $v$.
  \item [Retorna:] un iterador \Code{i} a los vecinos de grado mayor o igual al de $v$.
  \item [Complejidad temporal:]
\end{description}


\begin{lstlisting}[caption={Ejemplo de uso de H\_neighbors. El código crea un grafo $G$ con el vertice 1, el vertice 2 y el vertice 3. Luego, mediante el iterador de $x$ se recorre sus vecinos de mayor o igual grado y el ciclo imprime ``3''.},gobble=2,float=ht,label={lst:pseudo:H_neighbors},emph={H_neighbors}]
  G := create_graph()
  x := insertVertex(G, 1);
  y := insertVertex(G, 2);
  v := add_vertex(G, 3, {x, y})
      for w in H_neighbors(x):
          print get_info(w)
\end{lstlisting}


\subsection{\Code{degree(v)}}
\label{sec:tad grafo:degree}

Dado un objeto \Code{v} que representa un vertice $v$ devuelve la cantidad de vecinos de dicho vertice. 

\begin{description}
  \item [Parámetros:] \Code{v} representa un vertice $v$.
  \item [Propósito:] Proveer al usuario de información sobre $v$.
  \item [Retorna:] un numero que representa la cantidad de vecinos de $v$.
  \item [Complejidad temporal:]
\end{description}


\begin{lstlisting}[caption={Ejemplo de uso de degree. El código crea un grafo $G$ con el vertice 1, el vertice 2 y el vertice 3. Luego se imprime el grado de $v$, es decir, ``2''.},gobble=2,float=ht,label={lst:pseudo:degree},emph={degree}]
  G := create_graph()
  x := insertVertex(G, 1);
  y := insertVertex(G, 2);
  v := add_vertex(G, 3, {x, y})
  print degree(v)
\end{lstlisting}


\section{La estructura $h$-grafo}
\label{sec:h-grafo}

En esta sección describimos la estructura $h$-grafo que usamos para implementar el TAD grafo descripto en la Seccion~\ref{sec:tad grafo}.  Esta estructura es particularmente apropiada para grafos ralos, i.e., grafos cuya arboricidad es baja.  Esto se ve reflejado en  las complejidades temporales esperadas, dado que las mismas dependen de la cantidad de aristas y la arboricidad del grafo.  La descripción la hacemos a alto nivel tal como en el paper.  La idea es explicar, a continuación, como esta compuesta la estructura interna del $h$-grafo y luego detallar cada uno de sus operaciones.


Conceptualmente, la estructura mantiene un objeto \texttt{v} para cada vértice $v$ del grafo $G$.  Este objeto \emph{representa} a $v$ y mantiene la tripla $(d(v), N(v), H(v))$.  Recordemos que:   
\begin{itemize}
\item $d(v)$ se refiere al grado del vértice
\item $N(v)$ representa a los vecinos de $v$ que tienen menor grado que $v$
\item $H(v)$ representa a los vecinos de $v$ que tienen al menos el grado de $v$.
\end{itemize}

 Obviamente $d(v)$ se representa usando un número. Para representar $N(v)$, el $h$-grafo mantiene (ver Figura) una lista con objetos que representan vecinos que tienen igual grado entre sí. Cada uno de estos vecinos,   llamémoslo $w$,  guarda un puntero a la lista $H(w)$ y otro puntero al lugar exacto dónde esta $v$ en $H(w)$.

Vale remarcar que los vértices son privados del grafo, en el sentido de que no se pueden manipular directamente.  En su lugar, el usuario modifica $v$ a través de un \emph{puntero} que obtiene al insertar el vértice (ver ).  Remarcamos que este puntero es un objeto inteligente en el sentido que no muestra la implementacion al usuario.

En el resto de esta sección describimos cómo implementar, usando la estructura $h$-grafo, cada una de las operaciones que el TAD Grafo soporta (ver Seccion~\ref{sec:tad grafo}).  Para que quede claro que estamos usando la estructura $h$-grafo, vamos a escribir cada operacion \texttt{oper(G, $\cdots$)} usando la notación punto, i.e., \texttt{G.oper($\cdots$)} a fin de remarcar que tenemos acceso a la estructura de \texttt{G}.

En esta sección se describirá el algoritmo para insertar aristas y vértices y el algoritmo para removerlos.
Cómo se dijo anteriormente, la estructura del $h$-graph consiste de tres elementos, $d(v)$ que es el grado del vértice, $N(v)$ es una lista de sublistas que representa al vecindario de $v$, cada sublista no vacía contiene a los vecinos de determinado grado. Las sublistas están ordenadas. $H(v)$ es una la lista que contiene a los vecinos que tienen al menos el grado de $v$.

$h$-graph mantiene un puntero directo a los objetos que representan a los vértices, aristas y listas.


\subsection{\texttt{G.insert\_vertex(N, info)}}
\label{sec:hgraph:insert_vertex}

%IDEA
El proceso para insertar un nuevo vértice $v$ en $G$ se divide en dos partes.  Primero, la inserción de un nuevo objeto $v$ que representa un vértice aislado.  Segundo, la inserción de una arista entre $v$ y cada uno de los vértices representados por $N$.  Claramente, el grafo obtenido representa a $G + v$.

\subsubsection*{Pseudocódigo}

\begin{lstlisting}[float=h]
G.insert_vertex(N, info):
    v := G.append((0, [], []))
    for w in N:
        G.insert_edge(v, w)
\end{lstlisting}


\subsection{\texttt{G.insert\_edge(v, w)}}
\label{sec:hgraph:insert_edge}

El algoritmo para insertar la nueva arista $vw$ al grafo $G$, siendo $v$ y $w$ vértices de $G$, tiene tres fases bien delimitadas que describimos a continuación.
\begin{description}
\item [Primer fase.] La primer fase consiste en actualizar los vecindarios de $v$ y $w$.  Recordemos que $H(v)$ contiene aquellos vecinos de $v$ que tienen grado al menos $d(v)$.  Como $d(v)$ se incrementa en $1$ cuando agregamos la nueva arista $vw$, estamos obligados a sacar de $H(v)$ aquellos vértices cuyo grado es exactamente $d(v)$.  Claramente, cada vértice $z \in H(v)$ que tenemos que sacar tiene grado $d(v)$.  Por lo tanto, tenemos que colocar todos estos vertices en un nueva lista que represente a $N(v, d(v))$.  Entonces, para actualizar el vecindario de $v$,  agregamos a $\N(v)$ una nueva lista $N(v,d(v))$, y movemos cada $z \in H(v)$ de grado $d(v)$ hacia $N(v,d(v))$.  Para mover el vértice $z$, tenemos que actualizar los punteros involucrados.  Notemos que al mover el objeto \texttt{z} que representa a $z$ de $H(v)$ a $N(v, d(v))$, tanto el self pointer de \texttt{z} (que indica dónde se encuentra representado $v$ en $N(z)$) como su list pointer (que indica la lista que contiene a $v$ en $N(z)$) son correcto.  En cambio, tenemos que actualizar el list pointer y el self pointer del objeto \texttt{v} que representa a $v$ en $N(z)$.  Análogamente, para actualizar el vecindario de $w$, agregamos una lista $N(w, d(w))$ a $\N(w)$ y movemos cada $z \in H(w)$ de grado $d(w)$ hacia $N(w, d(w))$.  Vale remarcar que $N(v,d(v))$ (resp.\ $N(w, d(w))$) se crea solo si existe algún vecino de $v$ (resp.\ $w$) con grado $d(v)$ (resp.\ $d(w)$).  

\item [Segunda fase.]  La segunda fase consiste en actualizar el vecindario $N(z)$ de cada vértice $z$ que sea vecino de $v$ o $w$.  Notemos que si $v \in H(z)$ antes de la inserción, entonces $v \in H(z)$ luego de inserción, y por lo tanto el objeto que representa a $v$ no debe actualizarse.  En cambio, si $v \not\in H(z)$, entonces $d(v) < d(z)$ en $G$ y $v \in N(z, d(v)) \in \N$.  Por lo tanto, tenemos que mover $v$ desde $N(z,d(v)$) hacia $N(z, d(v)+1)$ para todo $z \in H(v)$ (por simplicidad, consideramos que $N(z, d(z)) = H(z)$).  Para esto, recorremos cada $z \in H(v)$ que tenga grado a mayor a $d(v)$ y movemos el objeto \texttt{v} que representa a $v$ en $N(z)$.  Notemos que dicho objeto \texttt{v} es el apuntado por el self pointer del objeto \texttt{z} que representa a $z$ en $H(v)$.  Por lo tanto, podemos acceder eficientemente a \texttt{v} para moverlo, actualizando los self y list pointers de \texttt{z}.  Una vez finalizado el procesamiento de $H(v)$, tenemos que proceder de manera análoga con $H(w)$.
%
\item [Tercer fase.] Por último, tenemos que agregar físicamente a $vw$ en $G$.  Para ello, creamos un objeto \texttt{w} que represente a $w$ en $N(v)$ y otro \texttt{v} que represente a $v$ en $N(w)$, y aumentamos el grado de $v$ y $w$ en $1$.
\end{description}
A continuación presentamos el pseudocódigo del algoritmo con sus tres fases correspondientes.

\begin{lstlisting}
G.insert_edge(v,w):
  //Fase 1
  G.update_neighborhood(v)
  G.update_neighborhood(w)
  //Fase 2
  G.update_neighbors(v)
  G.update_neighbors(w)
  //Fase 3 (insercion fisica)
  Insertar un nuevo objeto v al final de N(w, d(v))
  Insertar un nuevo objeto w al final de N(v, d(w))
  poner v->self_pointer := ultimo de N(v, d(w))
  poner v->list_pointer := N(v, d(w))
  poner w->self_pointer := ultimo de N(w, d(v))
  poner w->list_pointer := N(w, d(v))
\end{lstlisting}

\begin{lstlisting}
G.update_neighborhood(v):
    crear una nueva lista N(v,d(v))
    para cada z in H(v) si d(v) = d(z):
        mover z de H(v) a N(v, d(v))
        //Obs: z->self_pointer es el objeto que representa a v en N(z)
        poner z->self_pointer->list_pointer := N(v,d(v))
    si N(v,d(v)) tiene elementos, entonces insertar N(v,d(v)) al final de N(v) 
\end{lstlisting}

\begin{lstlisting}
G.update_neighbors(v):
    para cada z in H(v) si d(v) < d(z):
        //Obs: z->self_pointer es el objeto que representa a v en N(z),
        sea v' := z->self_pointer
        //     y z->list_pointer es el objeto que representa N(z, d(v)) en N(z)
        sea N(z,d(v)) := z->list_pointer
        Si la lista que sigue a N(z, d(v)) en N(z) no corresponde a vertices de grado d(v)+1, entonces
            Agregar una nueva lista N(z, d(v)+1) a continuacion de N(z,d(v))
        Mover v' de N(z, d(v)) a N(z, d(v)+1).
        Si N(z, d(v)) queda vacia, entonces remover N(z,d(v)) de N(z)
\end{lstlisting}

Ejemplo de una ejecucion.

\subsection{\texttt{G.remove\_edge(v,w)}}
\label{sec:hgraph:remove_edge}

El algoritmo para remover la arista $vw$ del grafo $G$ consiste en deshacer, en el orden inverso, las tres fases que usamos para su inserción (ver Seccion~\ref{sec:hgraph:insert_edge})

\begin{description}
\item[Deshacer tercer fase.] Recordemos que la tercer fase del proceso de inserción de $vw$ consiste en agregar físicamente la arista $vw$.  Luego, para deshacer la tercer fase tenemos que remover físicamente a $vw$ de $G$.  Supongamos, invirtiendo $v$ con $w$ de ser necesario, que $d(v) \leq d(w)$, i.e., $w$ ${\in}$ $H(v)$.  El primer paso es recorrer $H(v)$ hasta localizar al objeto \texttt{w} que representa a $w$ en $H(v)$.  En el segundo paso, usamos el list y self pointers de \texttt{w}, para acceder y borrar la encarnación \texttt{v} de $v$ en la lista \Code{N(w,d(v))}.  Por último, eliminamos a \texttt{w} de $H(v)$ y decrementamos en $1$ el grado de $v$ y $w$.

\item[Deshacer segunda fase.] Al igual que para la inserción, la segunda fase consiste en actualizar el vecindario $N(z)$ de cada vértice $z$ que sea vecino de $v$ o $w$.  Obviamente, en este caso, la actualización refleja la remoción de $vw$.  Notemos que si $d(v) \geq d(z)$ luego de deshacer la tercer fase, entonces $v \in H(z)$ tanto antes como luego del borrado.  En consecuencia, no hace falta actualizar la encarnación de $v$ en $N(z)$.  En cambio, si $d(v) < d(z)$ luego de deshacer la tercer fase, entonces $z \in H(v)$, con lo cual tenemos que mover la encarnación \Code{v} de $v$ desde $N(z,d(v)+1)$ a $N(z, d(v))$.  (Notar que, en caso en que $v \in H(z)$, \Code{N(z, d(v)+1)} representa a $H(z)$.)  Para ello, recorremos cada encarnación \Code{z} de $z \in H(v)$ y, haciendo uso de sus list y self pointer, accedemos a la encarnación \Code{v} de $v$ en $N(z,d(v)+1)$ y la movemos físicamente a $N(z,d(v))$.  Por último, actualizamos el list pointer de \Code{z} para que apunte a $N(z,d(v))$ y el self pointer de \Code{z} para que apunte a la encarnación de $v$ en $N(z,d(v))$.

\item[Deshacer primer fase.] En esta fase actualizamos el vecindario de $v$ y $w$, a fin de reflejar la remoción de $vw$.  Recordemos que en la primer fase de inserción de $vw$ movimos cada $z \in H(v)$  de grado $d(v)$ a una lista $N(v,d(v))$, debido a que $d(v)$ aumentaba en 1. Para deshacer este proceso, movemos cada vértice $z$ $\in N(v,d(v))$  hacia $H(v)$. Recordemos que en el $h$-graph cada lista $N(d(v))$ es una lista no vacía, razón por la cual $N(v,d(v))$ es finalmente eliminada.

a continuación el pseudocódigo.
\end{description}

\begin{lstlisting}[caption={Implementación de \Code{remove_edge}, deshaciendo las tres fases de la \Code{insert_edge}.},name=remove_edge,gobble=2,float=ht,label={lst:hgraph:remove_edge},commentstyle={\color{red}},morecomment={[l]{//}}]
  G.remove_edge(v,w) {
      if grado(v) > grado(w): swap(v,w)
      //Deshacer Fase 3
      w := buscar w en H(v)
      borrar a w->self_pointer de w->list_pointer
      borrar w de H(v)
      grado(v) := grado(v) - 1.
      grado(w) := grado(w) - 1.
      //Deshacer Fase 2
      G.update_neighbors_delete(v)
      G.update_neighbors_delete(w)
      //Deshacer Fase 2
      G.update_neighborhood_delete(v)
      G.update_neighborhood_delete(w)
  }
  
  G.update_neighbors_delete(v) {
      para cada z en H(v) {
          Mover z->self_pointer de z->list_pointer al inicio de prev(z->list_pointer)
          Borrar z->list_pointer si queda vacia
          z->list_pointer := prev(z->list_pointer)
          z->self_pointer := primero de z->list_pointer
      }
  }
  
  G.update_neighborhood_delete(v){
      Si los vertices en prev(H(v)) no tienen grado d(v), retornar
      para cada z en prev(H(v)) {
          mover z al inicio de H(v)
          //z->self_pointer es el objeto que representa a v en N(z).
          z->self_pointer->list_pointer := H(v)
          z->self_pointer->self_pointer := primero de H(v)
      }
      Borrar prev(H(v))
  }
\end{lstlisting}


\section{Implementación en C ++}
\label{sec:c++}

En esta sección vamos a describir todos los detalles de la implementación de la estructura $h$-grafo en el lenguaje C++.  La Sección~\ref{sec:c++:interfaz} describe la interfaz pública, mientras que la Sección~\ref{sec:c++:estructura} describe la estructura interna y sus algoritmos.  

Tal como vimos en la Sección~\ref{sec:h-grafo}, la estructura $h$-grafo guarda, para cada  vértice $v$, una lista $N(v, d)$ que contiene todos los vecinos de $v$ de grado $d$.  Como veremos en la Sección~\ref{sec:c++:estructura}, la idea es utilizar el tipo \texttt{std::list} de C++ para almacenar los vértices en $N(v, d)$.  Pero, cada objeto \texttt{z} de $N(v, d)$ debe contener un puntero al objeto \texttt{v} que representa a $v$ en $N(z, d(v))$.  Obviamente, como los nodos de \texttt{std::list} son privados, no hay forma de obtener un puntero crudo a dicho nodo físico.  Para resolver este problema, tenemos que usar un objeto que nos permita realizar las operaciones que requerimos de la lista, sin romper su estructura.  En C++, los objetos que se comportan como estos \emph{punteros restringidos} son los iteradores.  

En la Sección~\ref{sec:hgraph:insert_vertex} también mencionamos que \texttt{G.insert\_vertex()} retorna un ``puntero'' al objeto \texttt{v} que representa al nuevo vértice insertado.  Estos punteros no permiten acceder indiscriminadamente a la estructura interna del grafo $G$.  Más aún, el usuario de dicho puntero no debería conocer la estructura interna de $G$.  Para modificar algún aspecto de $v$, el usuario debe invocar un método de $G$ brindando \texttt{v} como parámetro.  Por otra parte, la estructura $h$-grafo ofrece distintos iteradores para recorrer los vértices y las aristas de $G$.  Siguiendo la filosofía de la biblioteca estándar, los punteros que se usan para manipular a $G$ se corresponden con estos iteradores.

\subsection{Interfaz de C++}
\label{sec:c++:interfaz}
Tal como mencionamos anteriormente, en esta sección describiremos la interfaz pública del $h$-grafo.
La clase \textbf{Graph} que es la que posee los métodos visibles para el usuario.
Respetando la naturaleza del $h$-graph el usuario no tiene acceso a los vértices. Por eso se diseñaron varios iteradores para recorrer la estructura.
Recordemos que los iteradores sirven para recorrer una estructura sin tener en cuenta la forma en que fue implentada y a su vez se pueden utilizar como punteros a la estructura pero sin exponerla.

En la implementación del $h$-graph se provee al usuario tres tipos de iteradores:

\subsubsection{const\_vertex\_iterator}
\label{sec:vertex iterator}
El \textbf{const\_vertex\_iterator} es un iterador bidireccional que apunta a un vértice. Este iterador se obtiene al agregar un nuevo vértice al grafo. Este iterador le va servir al usuario para manipular el grafo, ya sea para agregar o borrar una arista, borrar un vértice o recorrer todos los vértices del grafo. Sin embargo, el iterador no permite al usuario modificar directamente información del vértice, como por ejemplo el grado.

Para recorrer todos los vértices del grafo, la clase Graph posee los métodos \textit{begin()} y \textit{end()} que retornan el iterador const\_vertex\_iterator.

Ejemplo de uso del \textbf{const\_vertex\_iterator}

\begin{lstlisting}[frame=single]
tip::Graph<int> G;
const_vertex_iterator v1 = G.insertVertex(1);
const_vertex_iterator v2 = G.insertVertex(2);

G.add_edge(v1,v2);

void print_vertices( Graph& G) {
    for(auto it = G.begin(); it != G.end(); ++it) {
        cout << *it << endl;
    }
}
\end{lstlisting}

\subsubsection{deg\_iterator}
\label{sec:deg_iterator}

\textbf{deg\_iterator}: es un iterador bidireccional que permite iterar el highNeighborhood de un vértice. Este iterador es propio de la clase \textit{Vertex}. El usuario para obtener este iterador, lo hace a través de la clase \textit{Graph} con los métodos 
\textit{H\_begin()}, \textit{H\_end()}, lo cuales le permiten iterar el \textit{HighNeighborhood} del vértice.

Ejemplo de uso del \textbf{deg\_iterator}

\begin{lstlisting}[frame=single]
tip::Graph<int> G;
const_vertex_iterator v1 = G.insertVertex(1);
const_vertex_iterator v2 = G.insertVertex(2);

for(auto it = G.H_begin(v1); it != G.H_end(v1); ++it) {
              cout << *it << ',';
          }
\end{lstlisting}

\subsubsection{neighbor\_iterator}
\label{sec:neighbor iterator}
\textbf{neighbor\_iterator}: es un iterador bidireccional que permite iterar todos los vecinos de un vértice. Es un iterador privado de la clase \textit{Vertex}. El usuario tiene acceso a él a través de la clase \textit{Graph} con los métodos \textit{N\_begin(const\_vertex\_iterator v))} y \textit{N\_end(const\_vertex\_iterator v))}

                        Ejemplo de uso del \textbf{neighbor\_iterator}
\textit{}
            \begin{lstlisting}[frame=single]
            tip::Graph<int> G;
            const_vertex_iterator v1 = G.insertVertex(1);
            const_vertex_iterator v2 = G.insertVertex(2);

            for(auto it = G.N_begin(v1); it != G.N_end(v1); ++it) {
                          cout << *it << ',';
                      }
            \end{lstlisting}

Respetando el TAD grafo descripto en la sección \ref{sec:tad grafo} la clase \Code{Graph} ofrece los siguientes métodos:
\subsubsection{insertVertex}
\label{sec:insertVertex}
\Code{insertVertex(const Elem\& elem)}: Su propósito es insertar un nuevo vértice al grafo.
El tipo de retorno del método es un iterador \Code{const\_vertex\_iterator} (\ref{sec:vertex iterator}), recordemos que este iterador es el que va a permitir al usuario agregar y borrar aristas.


\subsubsection{remove\_vertex}
\label{sec:remove-vertex}

\Code{remove\_vertex(const\_vertex_iterator v)}: Su propósito es eliminar un vértice \Code{v} del grafo y dejar en forma consistente el vecindario de los demás vértices con los que el vértice \Code{v} tenía relación. Esto significa eliminar las aristas que involucraban a \Code{v}.
El método no tiene ningún tipo de retorno.



\subsubsection{add\_edge}
\label{sec:add-edge}
\Code{add\_edge(const\_vertex\_iterator v, const\_vertex\_iterator w)}: Su propósito es crear la relación entre el vértice \Code{v} y el vértice \Code{w}. Deja en forma consistente el vecindario de \Code{v} y el vecindario de \Code{w}.

\subsubsection{remove\_edge}
\label{sec:remove-edge}
\Code{remove\_edge(const\_vertex\_iterator v, const\_vertex\_iterator w)}: su propósito es eliminar la relación entre los vértices \Code{v} y el vértice \Code{w}. Deja en forma consistente los vecindarios de los dos vértices.

Toma como parámetro un iterador que apunta a \Code(v) y otro que apunta a \Code{w}.

El método no tiene ningún tipo de retorno.











\subsection{Estructura en C++}
\label{sec:c++:estructura}

En esta sección describiremos la estructura interna de la estructura $h$-grafo, tal cual está implementada en C++.  El código de la estructura se encuentra organizada en 3 archivos fuente:
\begin{description}
  \item[\Code{Graph.h}:] contiene la estructura general del $h$-grafo.
  \item[\Code{Vertex.h}:] contiene la descripción de lo que es un vértice.
  \item[\Code{Neighbor.h}] contiene la estructura de un vecino.
\end{description}
A continuación describimos las clases principales del $h$-grafo, indicando el archivo en el que esta definida.

\subsubsection{Graph (Graph.h)}
\label{sec:c++:estructura:Graph.h}

Recordemos que el tipo Grafo que implementamos es un tipo paramétrico que permite asociar información de algún tipo a cada vértice.  La representación de un grafo, usando la clase \Code{Graph<Elem>} es sencilla en términos conceptuales, ya que simplemente es una lista de \Code{Vertex} (ver Seccion~\ref{sec:c++:estructura:Vertex.h}).  

La clase \Code{Graph} también define las estructuras centrales de representación para los vecindarios


Como veremos en la Sección~\ref{sec:c++:estructura:Vertex.h}, la clase \Code{Vertex} mantiene toda la información de los vecinos de un vértice.  En consecuencia, \Code{Vertex} es una componente central de la estructura.  Por este motivo, \Code{Vertex} necesita tener acceso a algunas partes privadas del grafo, razón por la cual, \Code{Graph<Elem>} es \Code{friend} de \Code{Vertex}.  En particular, \Code{Vertex} necesita saber de qué tipo es \Code{Elem} para saber cómo almacenar la información de un vértice.  Un inconveniente central a la hora de definir el tipo \Code{Graph<Elem>}, es que el mismo necesita conocer qué es un \Code{Vertex}, mientras que, por lo mencionado anteriormente, \Code{Vertex} necesita conocer el tipo \Code{Elem}.  Con lo cual, hay un inconveniente serio a la hora de decidir qué clase se crea primero.  Una solución simple a este problema es usar el \emph{Curiously recurring template pattern (CRTP)}~\cite{}, que consiste escribir el tipo interno \Code{Vertex} como un tipo paramétrico \Code{Vertex<Graph>} que depende \Code{Graph<Elem>} que lo utilice.  Luego, \Code{Graph<Elem>} puede utilizar una instancia de \Code{Vertex<Graph>}.  Más allá del patrón de implementación, la estructura no deja de ser una lista de vertices.


\begin{lstlisting}[language={C++},caption={Estructura del tipo Grafo en C++.},gobble=2,float=ht,label={lst:c++:graph}]
    template<class Elem> class Graph
    {
        using elem_type = Elem;
    private:
        friend class impl::Vertex<Graph>;
        friend class impl::Neighbor<Graph>;
    
        //CRTP: Curiously recurring template pattern
        using Vertex = impl::Vertex<Graph>; 
        using Neighbor = impl::Neighbor<Graph>;
        
        using Vertices = std::list<Vertex>;
        using degNeighborhood = std::list<Neighbor>;
        using Neighborhood = std::list<degNeighborhood>;
        using neighbor_iterator = typename Vertex::neighbor_iterator;
        using deg_iterator = typename Vertex::deg_iterator;
    };
\end{lstlisting}

\subsubsection{Vertex (Vertex.h)}
\label{sec:c++:estructura:Vertex.h}

De acuerdo a lo visto en la Sección~\ref{sec:c++:estructura:Graph.h}, \Code{Vertex} es un tipo paramétrico que representa una instancia de un vértice $v$ del $h$-grafo.  El parámetro esperado para el template \Code{Vertex} es un clase de \Code{Graph}.  Vale remarcar que el tipo \Code{Vertex} se usa únicamente dentro de la clase \Code{Graph}, quien no exhibe su interfaz interna.  En otras palabras, \Code{Vertex} es invisible al usuario de \Code{Graph}, más allá de que todos sus miembros sean públicos.

La clase \Code{Vertex} posee la información asociada con el vértice (\Code{elem}), el grado del vértice (\Code{degree}) y su vecindario (\Code{neighborhood}).  Como vimos en la Sección~\ref{sec:h-grafo}, el vecindario en el $h$-grafo se organiza como una lista de listas, cuyos elementos representan las listas no vacías de $N(v, 0), \ldots, N(v, d(v)-1)$ y $H(v)$.  Cada lista $N(v, i)$ guarda los vecinos de grado $i$ y $H(v)$ guarda los vecinos de grado al menos $d(v)$.  Para la representación en C++, por comodidad, almacenamos $H(v)$ como la última lista \Code{neighborhood}.

Recordemos que \Code{Graph} concentra las definiciones de qué significa cada tipo, incluyendo qué estructura se usa para representar un vecindario $N(v)$ (\Code{Neighborhood}), qué estructura se usa para representar cada lista $N(v, i)$ y $H(v)$ dentro del vecindario (\Code{degNeighborhood}), y qué estructura se usa para representar un vecino que contiene los self y list pointers (\Code{Neighbor}).  Por simplicidad, renombramos estos tipos dentro de la estructura de \Code{Vertex}.

\begin{lstlisting}[language={C++},caption={Estructura del tipo Grafo en C++.},gobble=2,float=ht,label={lst:c++:graph}]
  template<class Graph> struct Vertex
  {
      //Tipo del elemento que se guarda en los vertice;
      //notar que es el tipo que el usuario indica en la clase Graph
      using elem_type = typename Graph::elem_type;
  
      //Estructura donde se guardan los vertices
      using Vertices = typename Graph::Vertices;
      //Estructura de vecino.
      using degNeighborhood = typename Graph::degNeighborhood;
      //Estructura donde se guardan todos los vecindarios de todos los grados.
      using Neighborhood = typename Graph::Neighborhood;
      
      elem_type elem;  //elemento
      size_t degree;  //grado
      Neighborhood neighborhood;  //vecindario
  }
\end{lstlisting}

\subsubsection{Neighbor (Neighbor.h)}
\label{sec:c++:estructura:Neighbor.h}

Los objetos de esta clase se van a almacenar en listas que juntas representan el vecindario $N(v)$ de un vértice $v$.

Cada \Code{Neighbor} representa un vecino $w$ de $v$ que mantiene toda la información necesaria para que sea eficiente eliminar $v$ de $N(w)$ cuando se tiene acceso a $w$ en $N(v)$, como se vio en la seccion ~\ref{sec:hgraph:remove_edge}

Esta estructura es simplemente una tripla de tres punteros:

\Code{neighbor}: que es un iterador al vértice $v$ en la lista de vértices de \Code{Graph}, descripto en la sección \ref{sec:c++:interfaz} item (\ref{vertex iterator})

\Code{list_pointer}: es un puntero a la lista en que esta \Code{v} en \Code{w}

\Code{self_pointer}: es un puntero directo a v en $N(v)$.


\begin{lstlisting}[language={C++},caption={Neighbor.h},gobble=2,float=ht,label={lst:c++:graph}]
     struct Neighbor
        {
            using NeighborPtr = typename Graph::Vertices::iterator;
            using SelfPtr = typename Graph::degNeighborhood::iterator;
            using ListPtr = typename Graph::Neighborhood::iterator;
            using elem_type = typename Graph::Vertex::elem_type;

            Neighbor() = default;
            Neighbor(NeighborPtr neighbor) : neighbor(neighbor) {}

            /**
             * Es un puntero directo al vecino en la lista de vertices.
             */
            NeighborPtr neighbor;

            /**
             * Es un puntero directo a la posicion de v en la lista de N(w) que lo contiene.
             */
            SelfPtr self_pointer;

            /**
             * Es un puntero directo a la lista de L(w) que contiene a v. (Solo tiene en cuenta los low_neighborhood;
             * cuando v esta en high_neighborhood de w, dejamos low_neighborhood.end())
             */
            ListPtr list_pointer;
  }
\end{lstlisting}

\section{Resultados de la experimentación}
\label{sec:experimentación}
"tiempo vs complejidad"



\end{document}

















