\documentclass[a4paper,12pt]{article}

\usepackage[T1]{fontenc}%encoding de los fonts del pdf (para copiar y pegar)
\usepackage[spanish]{babel} %idioma español para los cortes de linea
\usepackage[utf8]{inputenc} %encoding del .tex
\usepackage{amsmath} %paquete de matematica
\usepackage[margin=1.5cm]{geometry} %margenes
\usepackage{enumerate} %mejor enumerate
\usepackage{xspace} %espacios despues de un comando
\usepackage[pdftitle={},pdfauthor={},pdfcreator={},pdfsubject={},pdfkeywords={},colorlinks=true,linkcolor=blue,citecolor=blue]{hyperref} %hiperlinks
\usepackage{listings} %para escribir codigo C++

\newcommand{\Grafo}{\textsc{Grafo}\xspace}
\newcommand{\Code}[1]{\texttt{#1}}
\newcommand{\N}{\mathcal{N}}

\lstset{
  numbers=left,
  numberstyle=\tiny,
  tabsize=2,
  frame=single,
  basicstyle={\scriptsize},
  aboveskip={0pt},
  belowskip={0pt}
}


\begin{document}

% Title of paper
\title{TIP:  Implementación de algoritmos y estructuras de datos eficientes para grafos}

% List of authors, with corresponding author marked by asterisk
\author{Alejandro Merlo \and Griselda Cardozo}
\date{(draft \today)} % Sin fecha.

\maketitle

\tableofcontents

\section{Resumen}
\label{sec:resumen}


\section{Introducción}
\label{sec:introduccion}

Decir qué es un grafo como objeto matemático (representa una relacion).  Un grafo es un par $G = (V, E)$ donde $V$ son vertices y $E$ son pares de vértices.  Los grafos se usan para modelar objetos de aplicaciones reales en forma abstracta.  Por ejemplo, en una red social blah.  La ventaja de los grafos es que proveen una terminologia comun, blah.  La teoría de grafos se encarga del estudio de grafos y, en particular, la teoria algoritmica de grafos se encarga de los problemas computacionales asociados.


Este trabajo surge de la necesidad de verificar la viabilidad y dificultad de implementar la estructura $h$-grafo descripta por Lin et al. en~\cite{}``Arboricity, $h$-index, and dynamic algorithms''.   Esta estructura implementa el \emph{tipo abstracto de datos} (TAD) \Grafo.  Esta estructura esta pensada para aplicaciones que utilizan grafos dinámicos.  Por \emph{dinámico} nos referimos a que permite la inserción y borrado de vértices y aristas, a la vez que provee funciones de consulta.  La ventaja de esta estructura es que es muy eficiente en grafos ralos, i.e., grafos que tienen una baja \emph{arboricidad}.  

La estructura $h$-grafo es conceptualmente simple.  La misma consiste de tres campos $(d(v), L(v), H(v))$ por cada vértice $v$ de un grafo $G$, donde $d(v)$ es el grado de $v$, $L(v)$ son los vecinos de $v$ con grado menor a $d(v)$ y $H(v)$ son los vecinos de $v$ con grado al menos $d(v)$.  Asimismo, la estructura mantiene una serie de punteros a fin de que las operaciones puedan resolverse eficientemente.  

Los objetivos principales de este trabajo son:
\begin{itemize}
  \item desarrollar el TAD grafo implementado con la estructura $h$-grafo,
  \item verificar que la eficiencia teórica coincide con la de nuestra implementación, y
  \item testear la eficiencia de la estructura en grafos ralos grandes.
\end{itemize}

El presente documento esta organizado de la siguiente forma.  En la Sección~\ref{} damos blah.  En la Seccion~\ref{} hacemos bleh.

\section{Preliminares}
\label{sec:definiciones}

Recordemos que uno de los objetivos de este trabajo es implementar un TAD grafo.  El TAD grafo representa el objeto \emph{grafo} que se estudia en matemática.  En esta sección presentamos las definiciones centrales de un grafo que impactan en el desarrollo de nuestro TAD.

%Definiciones matematicas
Un \emph{grafo} es un par $(V, E)$ donde $V$ \ldots (ver Figura~\ref{fig:definiciones} en donde se ejemplifican muchas de las definiciones).  Para cada $vw \in E$, decimos que $v$ y $w$ son \emph{vecinos} o \emph{adjacentes}.  El grado de $v$ es la cantidad de vecinos que tiene.  El $k$-vecindario de $v$ es el conjunto de todos los vecinos de $v$ que tienen grado $k$, para algun $k$ dado.  Al conjunto de todos los vecinos de $v$ lo llamamos, simplemente, su \emph{vecindario}.

\begin{figure}
  \centering
  \fbox{Figura de un grafo en el que mostramos las definciones}

  \caption{Grafo cuyo conjunto de vertices es $V = $ y cuyo conjunto de aristas es $E =$.  En este grafo.}\label{fig:definiciones}
\end{figure}


Camino: es cualquier subconjunto de aristas contiguas, es decir, donde se cumpla que para cada par de aristas, el último vértice de la primer arista es el mismo que el primer vértice de la segunda arista; salvando el caso de la primera y de la última arista que pueden cumplir o no este requisito.  Circuito: es un subconjunto de las aristas del grafo que forman un camino donde el primer vertice es el último en ser accedido.  Bosque: es aquel grafo que no tiene circuitos.  Arboricidad: es la mínima cantidad de bosques con aristas disjuntas que se pueden formar dentro del grafo.

\section{El Tipo Grafo}
\label{sec:tad grafo}

El propósito de esta sección es presentar la interfaz abstracta del objeto grafo que implementaremos.  Este objeto es dinámico en el sentido \ldots.  Asimismo, ofrece distintas operaciones de consulta, que estan pensadas para poder recorrer eficientemente el vecindario de las distintas aristas del grafo.  Estas operaciones son muy utiles, por ejemplo, cuando uno quiere analizar la estructura local del grafo.  Es decir, cómo se conectan los vecinos de un vertice $v$ dado.  

Para describir la interfaz del TAD grafo, vamos a detallar cada una de las operaciones junto con sus propositos y sus requerimientos.  Esta descripción será de alto nivel tal y como se desarrolla en~\cite{}.  La idea de esta descripcion es fijar los conceptos necesarios para la posterior descripcion de su implementación en el lenguaje C++.  Asimismo, mostraremos un ejemplo de su uso potencial y describiremos la complejidad temporal esperada.  Obviamente, esta complejidad está en función de la implementación que describimos en la Seccion~\ref{sec:h-grafo}.  

\subsection{\texttt{create\_graph()}}
\label{sec:tad grafo:create-graph}

Crea un objeto \texttt{G} que representa un grafo $G$ de elementos \texttt{elem}. Retorna un puntero \texttt{G} al nuevo grafo creado. Este objeto guarda cierta información correspondiente a los vertices y sus vecinos

\begin{description}
  \item [Propósito:] crea un \texttt{G} sin vertices ni aristas.
  \item [Retorna:] un puntero \texttt{G} al grafo $G$.
  \item [Complejidad temporal:]
\end{description}

\paragraph{Ejemplo de uso}

El siguiente codigo crea un grafo $G$ vacío.

\begin{lstlisting}
G := create_graph()
\end{lstlisting}


\subsection{\texttt{insert\_vertex(G, info)}}
\label{sec:tad grafo:insert-vertex}

Modifica un objeto \texttt{G} que representa un grafo $G$, a fin de representar el grafo $H$ que se obtiene de insertar un nuevo vértice $v$ en $G$.  Retorna un puntero \texttt{v} al nuevo vértice $v$ agregado.  Este puntero \texttt{v} debe usarse para interactuar con $G$ a fin de modificar sus propiedades.  Notar que el vértice $v$ es un objeto conocido sólo por $G$ y no es compartido con otros grafos.  A este vertice se le puede asociar cierta información que es la reflejada por el parametro \texttt{info}.  Blah
  
\begin{description}
  \item [Parámetros:] \texttt{G} representa un grafo $G$ e \texttt{info} es cualquier objeto.
  \item [Propósito:] modifica \texttt{G} para representar un grafo $G + v$.
  \item [Retorna:] un puntero \texttt{v} al vértice $v$.
  \item [Complejidad temporal:]
\end{description}

\paragraph{Ejemplo de uso}

El siguiente código crea un grafo $G$ con dos vértices, ambos con la letra ``a'' como información.  Luego, el ciclo imprime ``aa'' como resultado.  Ver Sección~\ref{sec:tad grafo:vertex-iterator} para más información de \texttt{vertex\_iterator}.

\begin{lstlisting}
G := create_graph()
v := insert_vertex(G, 'a')
w := insert_vertex(G, 'a')
for v in vertex_iterator(G):
  print get_info(v)
\end{lstlisting}


\subsection{\texttt{remove\_vertex(G, v)}}
\label{sec:tad grafo:remove-vertex}

Modifica un objeto \texttt{G} que representa un grafo $G$, a fin de representar el grafo $H$ que se obtiene de remover el vértice existente \texttt{v} que representa al vertice $v$ en $G$.
  
\begin{description}
  \item [Parámetros:] \texttt{G} representa un grafo $G$ y \texttt{v} representa un vertice existente $v$ de $G$.
  \item [Propósito:] modifica \texttt{G} para representar un grafo $G - v$.
  \item [Complejidad temporal:]
\end{description}

\paragraph{Ejemplo de uso}

El siguiente código crea un grafo $G$ con dos vértices, el primero \texttt{v} representa al vértice $v$ con la letra 'a' y el segundo \texttt{w} representa al vértice $w$ con la letra 'b' como infomación. Luego, remueve \texttt{v} del grafo y el ciclo imprime ``b'' como resultado. Ver Sección~\ref{sec:tad grafo:vertex-iterator} para más información de \texttt{vertex\_iterator}.

\begin{lstlisting}
G := create_graph()
v := insert_vertex(G, 'a')
w := insert_vertex(G, 'b')
remove_vertex(G, v)
for vt in vertex_iterator(G):
  print get_info(vt)
\end{lstlisting}


\subsection{\texttt{add\_edge(G, v, w)}}
\label{sec:tad grafo:add-edge}

Modifica un objeto \texttt{G} que representa un grafo $G$, a fin de representar el grafo $H$ que se obtiene de agregar la arista $vw$ conformada por \texttt{v} y \texttt{w} que representan los vertices $v$ y $w$ en $G$.

\begin{description}
  \item [Parámetros:] \texttt{G} representa un grafo $G$, \texttt{v} y \texttt{w} representan los vertices existentes $v$ y $w$ de $G$.
  \item [Propósito:] modifica \texttt{G} para representar un grafo $G + vw$.
  \item [Complejidad temporal:]
\end{description}

\paragraph{Ejemplo de uso}

El siguiente código crea un grafo $G$ con dos vértices, el primero \texttt{v} representa al vértice $v$ con el número 1 y el segundo \texttt{w} representa al vértice $w$ con el número 2 como infomación. Luego, crea la arista $vw$ entre estos dos vertices dentro del grafo $G$. El ciclo imprime cada uno de los valores de los vecinos de $v$, en este caso como $w$ es su único vecino imprime ``2''. Ver Sección~\ref{sec:tad grafo:neighbor-iterator} para más información de \texttt{neghbor\_iterator}.

\begin{lstlisting}
G := create_graph()
v := insert_vertex(G, 1)
w := insert_vertex(G, 2)
add_edge(G, v, w)
for n in neighbor_iterator(v):
  print get_info(n*)
\end{lstlisting}


\subsection{\texttt{remove\_edge(G, v, w)}}
\label{sec:tad grafo:remove-edge}

Modifica un objeto \texttt{G} que representa un grafo $G$, a fin de representar el grafo $H$ que se obtiene de remover la arista $vw$ conformada por \texttt{v} y \texttt{w} que representan los vertices $v$ y $w$ en $G$.

\begin{description}
  \item [Parámetros:] \texttt{G} representa un grafo $G$, \texttt{v} y \texttt{w} representan los vertices existentes $v$ y $w$ de $G$.
  \item [Propósito:] modifica \texttt{G} para representar un grafo $G - vw$.
  \item [Complejidad temporal:]
\end{description}

\paragraph{Ejemplo de uso}

El siguiente código crea un grafo $G$ con dos vértices, el primero \texttt{v} representa al vértice $v$ con el número 1, el segundo \texttt{w} representa al vértice $w$ con el número 2 y el tercero \texttt{x} representa al vértice $x$ con el número 3 como infomación. Luego, crea las aristas $vw$ y $vx$ entre estos tres vertices dentro del grafo $G$ y consecuentemente se elimina la arista $vw$. El ciclo imprime cada uno de los valores de los vecinos de $v$, en este caso como $x$ termina siendo su único vecino imprime ``3''. Ver Sección~\ref{sec:tad grafo:neighbor-iterator} para más información de \texttt{neghbor\_iterator}.

\begin{lstlisting}
G := create_graph()
v := insert_vertex(G, 1)
w := insert_vertex(G, 2)
x := insert_vertex(G, 3)
add_edge(G, v, w)
add_edge(G, v, x)
remove_edge(G, v, w)
for n in neighbor_iterator(v):
  print get_info(n*)
\end{lstlisting}


\subsection{\texttt{add\_vertex(G, info, N)}}
\label{sec:tad grafo:add-vertex}

Modifica un objeto \texttt{G} que representa un grafo $G$, a fin de representar el grafo $H$ que se obtiene de agregar un nuevo vertice $v$ cuya información está reflejada en el parámetro \texttt{info} y una lista de punteros \texttt{N} que representa al vecindario $N$ que será asociado a $v$

\begin{description}
  \item [Parámetros:] \texttt{G} representa un grafo $G$, \texttt{info} es cualquier objeto y \texttt{N} representa el vecindario $N$.
  \item [Propósito:] modifica \texttt{G} para representar un grafo $G + vn$ donde $n$ es cada elemento de $N$.
  \item [Retorna:] un puntero \texttt{v} al vértice $v$.
  \item [Complejidad temporal:]
\end{description}

\paragraph{Ejemplo de uso}

El siguiente código crea un grafo $G$ con tres vertices, teniendo el tercer vertice, llamado $v$, a los otros dos como vecinos. Luego, el ciclo imprime ``12''.

\begin{lstlisting}
G := create_graph()
list<const_vertex_iterator> N;
N.push_back(insertVertex(G, 1));
N.push_back(insertVertex(G, 2));
v := add_vertex(G, 3, {N[1], N[2]})
for n in neighbor_iterator(v):
  print get_info(n*)
\end{lstlisting}




\section{La estructura $h$-grafo}
\label{sec:h-grafo}

En esta seccion describimos la estructura $h$-grafo que usamos para implementar el TAD grafo descripto en la Seccion~\ref{sec:tad grafo}.  Esta estructura es particularmente apropiada para grafos ralos, i.e., grafos cuya arboricidad es baja.  Esto se ve reflejado en que las complejidades temporales esperadas, dado que las mismas dependen de la cantidad de aristas y la arboricidad del grafo.  La descripción la hacemos a alto nivel tal como en el paper.  La idea es.


Conceptualmente, la estructura mantiene un objeto \texttt{v} para cada vértice $v$ del grafo $G$.  Este objeto \emph{representa} a $v$ y mantiene la tripla $(d(v), N(v), H(v))$.  Recordemos que:   
\begin{itemize}
\item $d(v)$ se refiere al grado del vértice
\item $N(v)$ representa a los vecinos de $v$ que tienen menor grado que $v$
\item $H(v)$ representa a los vecinos de $v$ que tienen al menos el grado de $v$.
\end{itemize}

 Obviamente $d(v)$ se representa usando un número. Para representar $N(v)$, el $h$-grafo mantiene (ver Figura) una lista con objetos que representan vecinos que tienen igual grado entre sí. Cada uno de estos vecinos,   llamémoslo $w$,  guarda un puntero a la lista $H(w)$ y otro puntero al lugar exacto dónde esta $v$ en $H(w)$.

Vale remarcar que los vértices son privados del grafo, en el sentido de que no se pueden manipular directamente.  En su lugar, el usuario modifica $v$ a través de un \emph{puntero} que obtiene al insertar el vértice (ver ).  Remarcamos que este puntero es un objeto inteligente en el sentido que no muestra la implementacion al usuario.

En el resto de esta sección describimos cómo implementar, usando la estructura $h$-grafo, cada una de las operaciones que el TAD Grafo soporta (ver Seccion~\ref{}).  Para que quede claro que estamos usando la estructura $h$-grafo, vamos a escribir cada operacion \texttt{oper(G, $\cdots$)} usando la notación punto, i.e., \texttt{G.oper($\cdots$)} a fin de remarcar que tenemos acceso a la estructura de \texttt{G}.

En esta sección se describirá el algoritmo para insertar aristas y vértices y el algoritmo para removerlos.
Cómo se dijo anteriormente, la estructura del $h$-graph consiste de tres elementos, $d(v)$ que es el grado del vértice, $N(v)$ es una lista de sublistas que representa al vecindario de $v$, cada sublista no vacía contiene a los vecinos de determinado grado. Las sublistas están ordenadas. $H(v)$ es una la lista que contiene a los vecinos que tienen al menos el grado de $v$.

$h$-graph mantiene un puntero directo a los objetos que representan a los vértices, aristas y listas.


\subsection{\texttt{G.insert\_vertex(N, info)}}

%IDEA
El proceso para insertar un nuevo vertice $v$ en $G$ se divide en dos partes.  Primero, la inserción de un nuevo objeto $v$ que representa un vértice aislado.  Segundo, la inserción de una arista entre $v$ y cada uno de los vértices representados por $N$.  Claramente, el grafo obtenido representa a $G + v$.

\subsubsection*{Pseudocódigo}

\begin{lstlisting}
G.insert_vertex(N, info):
    v := G.append((0, [], []))
    for w in N:
        G.insert_edge(v, w)
\end{lstlisting}


\subsection{\texttt{G.insert\_edge(v, w)}}

El algoritmo para insertar la nueva arista $vw$ al grafo $G$, siendo $v$ y $w$ vertices de $G$, tiene tres fases bien delimitadas que describimos a continuación.
\begin{description}
\item [Primer fase.] La primer fase consiste en actualizar los vecindarios de $v$ y $w$.  Recordemos que $H(v)$ contiene aquellos vecinos de $v$ que tienen grado al menos $d(v)$.  Como $d(v)$ se incrementa en $1$ cuando agregamos la nueva arista $vw$, estamos obligados a sacar de $H(v)$ aquellos vértices cuyo grado es exactamente $d(v)$.  Claramente, cada vértice $z \in H(v)$ que tenemos que sacar tiene grado $d(v)$.  Por lo tanto, tenemos que colocar todos estos vertices en un nueva lista que represente a $N(v, d(v))$.  Entonces, para actualizar el vecindario de $v$,  agregamos a $\N(v)$ una nueva lista $N(v,d(v))$, y movemos cada $z \in H(v)$ de grado $d(v)$ hacia $N(v,d(v))$.  Para mover el vértice $z$, tenemos que actualizar los punteros involucrados.  Notemos que al mover el objeto \texttt{z} que representa a $z$ de $H(v)$ a $N(v, d(v))$, tanto el self pointer de \texttt{z} (que indica dónde se encuentra representado $v$ en $N(z)$) como su list pointer (que indica la lista que contiene a $v$ en $N(z)$) son correcto.  En cambio, tenemos que actualizar el list pointer y el self pointer del objeto \texttt{v} que representa a $v$ en $N(z)$.  Análogamente, para actualizar el vecindario de $w$, agregamos una lista $N(w, d(w))$ a $\N(w)$ y movemos cada $z \in H(w)$ de grado $d(w)$ hacia $N(w, d(w))$.  Vale remarcar que $N(v,d(v))$ (resp.\ $N(w, d(w))$) se crea solo si existe algún vecino de $v$ (resp.\ $w$) con grado $d(v)$ (resp.\ $d(w)$).  

\item [Segunda fase.]  La segunda fase consiste en actualizar el vecindario $N(z)$ de cada vértice $z$ que sea vecino de $v$ o $w$.  Notemos que si $v \in H(z)$ antes de la inserción, entonces $v \in H(z)$ luego de inserción, y por lo tanto el objeto que representa a $v$ no debe actualizarse.  En cambio, si $v \not\in H(z)$, entonces $d(v) < d(z)$ en $G$ y $v \in N(z, d(v)) \in \N$.  Por lo tanto, tenemos que mover $v$ desde $N(z,d(v)$) hacia $N(z, d(v)+1)$ para todo $z \in H(v)$ (por simplicidad, consideramos que $N(z, d(z)) = H(z)$).  Para esto, recorremos cada $z \in H(v)$ que tenga grado al mayor a $d(v)$ y movemos el objeto \texttt{v} que representa a $v$ en $N(z)$.  Notemos que dicho objeto \texttt{v} es el apuntado por el self pointer del objeto \texttt{z} que representa a $z$ en $H(v)$.  Por lo tanto, podemos acceder eficientemente a \texttt{v} para moverlo, actualizando los self y list pointers de \texttt{z}.  Una vez finalizado el procesamiento de $H(v)$, tenemos que proceder de manera análoga con $H(w)$.
%
\item [Tercer fase.] Por último, tenemos que agregar físicamente a $vw$ en $G$.  Para ello, creamos un objeto \texttt{w} que represente a $v$ en $N(v)$ y otro \texttt{v} que represente a $v$ en $N(w)$, y aumentamos el grado de $v$ y $w$ en $1$.
\end{description}
A continuación presentamos el pseudocódigo del algoritmo con sus tres fases correspondientes.

\begin{lstlisting}
G.insert_edge(v,w):
  //Fase 1
  G.update_neighborhood(v)
  G.update_neighborhood(w)
  //Fase 2
  G.update_neighbors(v)
  G.update_neighbors(w)
  //Fase 3 (insercion fisica)
  Insertar un nuevo objeto v al final de N(w, d(v))
  Insertar un nuevo objeto w al final de N(v, d(w))
  poner v->self_pointer := ultimo de N(v, d(w))
  poner v->list_pointer := N(v, d(w))
  poner w->self_pointer := ultimo de N(w, d(v))
  poner w->list_pointer := N(w, d(v))
\end{lstlisting}

\begin{lstlisting}
G.update_neighborhood(v):
    crear una nueva lista N(v,d(v))
    para cada z in H(v) si d(v) = d(z):
        mover z de H(v) a N(v, d(v))
        //Obs: z->self_pointer es el objeto que representa a v en N(z)
        poner z->self_pointer->list_pointer := N(v,d(v))
    si N(v,d(v)) tiene elementos, entonces insertar N(v,d(v)) al final de N(v) 
\end{lstlisting}

\begin{lstlisting}
G.update_neighbors(v):
    para cada z in H(v) si d(v) < d(z):
        //Obs: z->self_pointer es el objeto que representa a v en N(z),
        sea v' := z->self_pointer
        //     y z->list_pointer es el objeto que representa N(z, d(v)) en N(z)
        sea N(z,d(v)) := z->list_pointer
        Si la lista que sigue a N(z, d(v)) en N(z) no corresponde a vertices de grado d(v)+1, entonces
            Agregar una nueva lista N(z, d(v)+1) a continuacion de N(z,d(v))
        Mover v' de N(z, d(v)) a N(z, d(v)+1).
        Si N(z, d(v)) queda vacia, entonces remover N(z,d(v)) de N(z)
\end{lstlisting}

Ejemplo de una ejecucion.

\subsection{\texttt{G.remove\_edge(v,w)}}

Para remover una arista $vw$, asumiremos que el $d(v)$ es ${\leq}$ a $d(w)$ , esto significa que  $w$ ${\in}$ $H(v)$.
El proceso de remoción de la arista comienza deshaciendo la segunda fase de inserción, esto es, disminuir $d(v)$ y  $d(w)$. Luego,  se remueve físicamente la arista $vw$. Para ello se recorre $H(v)$ para localizar y borrar el objeto que representa a $w$. Dado que el objeto que representa a $w$ guarda un puntero hacia donde está ubicado $v$ en $N(w)$ es fácil y rápido remover a $v$ desde $N(w,d(v))$.



Después se deshace la fase 1, que consiste en actualizar  los vecindarios de $v$ y $w$. Para eso se mueve a $v$ desde $N(z,d(v))$ hacia $N(z,d(v)-1)$ para cada $z$ ${\in}$ $H(v)$, luego se une a  $N(v,d(v)-1)$ con $H(v)$. Como se hizo en la inserción, se actualizan los punteros ante cada movimiento de los objetos.

Por último se repite el mismo procedimiento con el vértice $w$


\section{Implementación en C ++}
\label{sec:c++}

En esta sección vamos a describir todos los detalles de la implementación de la estructura $h$-grafo en el lenguaje C++.  La Sección~\ref{} describe la interfaz publica, mientras que la Sección~\ref{} describe la estructura interna y sus algoritmos.  

Tal como vimos en la Sección~\ref{}, la estructura $h$-grafo guarda, para cada vertice $v$, una lista $N(v, d)$ que contiene todos los vecinos de $v$ de grado $d$.  Como veremos en la Sección~\ref{}, la idea es utilizar el tipo \texttt{std::list} de C++ para almacenar los vertices en $N(v, d)$.  Pero, cada objeto \texttt{z} de $N(v, d)$ debe contener un puntero al objeto \texttt{v} que representa a $v$ en $N(z, d(v))$.  Obviamente, como los nodos de \texttt{std::list} son privados, no hay forma de obtener un puntero crudo a dicho nodo físico.  Para resolver este problema, tenemos que usar un objeto que nos permita realizar las operaciones que requerimos de la lista, sin romper su estructura.  En C++, los objetos que se comportan como estos \emph{punteros restringidos} son los iteradores.  

Que es un iterador de lista.

En la Sección~\ref{} también mencionamos que \texttt{G.insert\_vertex()} retorna un ``puntero'' al objeto \texttt{v} que representa al nuevo vértice insertado.  Estos punteros no permiten acceder indiscriminadamente a la estructura interna del grafo $G$.  Más aún, el usuario de dicho puntero no debería conocer la estructura interna de $G$.  Para modificar algún aspecto de $v$, el usuario debe invocar un método de $G$ brindando \texttt{v} como parámetro.  Por otra parte, la estructura $h$-grafo ofrece distintos iteradores para recorrer los vértices y las aristas de $G$.  Siguiendo la filosofía de la biblioteca estándar, los punteros que se usan para manipular a $G$ se corresponden con estos iteradores.





Los iteradores sirven para recorrer un contenedor, ocultando la estructura interna de éste. Para ello se valen de una interfaz común a todos los objetos iterables. Lo que permite usarlos como punteros seguros a la estructura interna sin exponerla.
En c++ existen distintos tipos de iteradores 

 \emph{output} e  \emph{input }son los más básicos, ellos pueden realizar operaciones de entrada o salida de manera secuencial. Soportan las operaciones ==, !=, *, ->

 \emph{Forward} esta diseñado para recorrer contenedores cuyos valores puedan ser añadidos y recuperados. Mantienen la restricción de que únicamente se pueden mover hacia delante

El  \emph{bidireccional}  tiene las funcionalidades del \emph{Forward} pero además  pueden avanzar al elemento siguiente o retroceder al elemento anterior.

\emph{Random access} son iteradores que pueden avanzar o retroceder más de una posición de una vez.

Todos los objetos iterables soportan el método \textbf{begin()} que devuelve un iterador al primer elemento a iterar.
El método \textbf{end()} retorna un iterador al final de la estructura. 

Para obtener el elemento al que apunta el iterador se usa el método de desreferencia *, tal como se hace con los punteros.



Ejemplo de uso de iteradores sobre una lista.



\lstset{language=C, breaklines=true, basicstyle=\footnotesize}
\begin{lstlisting}[frame=single]
void show_list( const list<string) & sList){
        list<string>:: const_iterator pos;
    
    //obtenemos un iterador al primer elemento
    pos = sList.begin();
    
    while( pos != sList.end()){ // mientras pos sea distinto al final de la lista
        cout<< *pos << endl;
        pos++;  //avanza el iterador
    }
}
\end{lstlisting}



\subsection{Interfaz de C++}




Existe una clase \textbf{Graph} que es la que posee los métodos visibles para el usuario.
\textbf{Graph} es un template. Los templates permiten crear estructuras de datos que no dependen del tipo de dato que reciban. De esta manera conseguimos una generalización del grafo.

Respetando la naturaleza del $h$-graph el usuario no tiene acceso a los vértices. Por eso se diseñaron varios iteradores para recorrer la estructura.
Recordemos que los iteradores sirven para recorrer una estructura sin tener en cuenta la forma en que fue implentada y a su vez se pueden utilizar como punteros a la estructura pero sin exponerla.

En la implementación del $h$-graph se provee al usuario tres tipos de iteradores:

\begin{enumerate}
\item  \textbf{const\_vertex\_iterator} : es un iterador bidireccional que apunta a un vértice. Este iterador se obtiene al agregar un nuevo vértice al grafo. Este iterador le va servir al usuario para manipular el grafo, ya sea para agregar o borrar una arista, borrar un vértice o recorrer todos los vértices del grafo. Sin embargo, el iterador no permite al usuario modificar directamente información del vértice, como por ejemplo el grado.

Para recorrer todos los vértices del grafo, la clase Graph posee los métodos \textit{begin()} y \textit{end()} que retornan el iterador const\_vertex\_iterator.

Ejemplo de uso del \textbf{const\_vertex\_iterator}

\begin{lstlisting}[frame=single]
tip::Graph<int> G;
const_vertex_iterator v1 = G.insertVertex(1);
const_vertex_iterator v2 = G.insertVertex(2);

G.add_edge(v1,v2);

void print_vertices( Graph& G) {
    for(auto it = G.begin(); it != G.end(); ++it) {
        cout << *it << endl;
    }
}
\end{lstlisting}

\item \textbf{deg\_iterator}: es un iterador bidireccional que permite iterar los vecinos de determinado grado de un vértice. Este iterador es propio de la clase \textit{Vertex}. El usuario para obtener este iterador, lo hace a través de la clase \textit{Graph} con los métodos 
\textit{H\_begin()}, \textit{H\_end()}, lo cuales le permiten iterar el \textit{HighNeighborhood} del vértice.

Ejemplo de uso del \textbf{deg\_iterator}

\begin{lstlisting}[frame=single]
tip::Graph<int> G;
const_vertex_iterator v1 = G.insertVertex(1);
const_vertex_iterator v2 = G.insertVertex(2);

for(auto it = G.H_begin(v1); it != G.H_end(v1); ++it) {
              cout << *it << ',';
          }
\end{lstlisting}


\item \textbf{neighbor\_iterator}: es un iterador bidireccional que permite iterar todos los vecinos de un vértice. Es un iterador privado de la clase \textit{Vertex}. El usuario tiene acceso a él a través de la clase \textit{Graph} con los métodos \textit{N\_begin(const\_vertex\_iterator v))} y \textit{N\_end(const\_vertex\_iterator v))}
\end{enumerate}
                        Ejemplo de uso del \textbf{deg\_iterator}

            \begin{lstlisting}[frame=single]
            tip::Graph<int> G;
            const_vertex_iterator v1 = G.insertVertex(1);
            const_vertex_iterator v2 = G.insertVertex(2);

            for(auto it = G.N_begin(v1); it != G.N_end(v1); ++it) {
                          cout << *it << ',';
                      }
            \end{lstlisting}



\subsection{Estructura en C++}




\subsubsection{Algoritmos en C++}
" Explicaciones detalladas de los algoritmos principales "


\section{Resultados de la experimentación}
\label{sec5}
"tiempo vs complejidad"



\end{document}
